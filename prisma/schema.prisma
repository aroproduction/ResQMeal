generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String            @id @default(uuid())
  email           String            @unique
  name            String
  password        String
  phone           String?
  role            UserRole          @default(RECEIVER)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  claims          Claim[]
  listings        Listing[]
  ngoDetails      NGODetails?
  notifications   NotificationLog[]
  providerDetails ProviderDetails?
  subscriptions   Subscription[]
  analytics       UserAnalytics?
  profile         UserProfile?

  @@map("users")
}

model UserProfile {
  id                  String  @id @default(uuid())
  userId              String  @unique
  avatar              String?
  bio                 String?
  campusId            String?
  department          String?
  studentId           String?
  employeeId          String?
  preferences         Json?
  sustainabilityScore Float?  @default(0)
  campus              Campus? @relation(fields: [campusId], references: [id])
  user                User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model NGODetails {
  id                 String                @id @default(uuid())
  userId             String                @unique
  ngoName            String
  registrationNo     String?
  website            String?
  description        String?
  servingAreas       Json?
  capacity           Int?
  verificationStatus NGOVerificationStatus @default(PENDING)
  verifiedAt         DateTime?
  verifiedBy         String?
  user               User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("ngo_details")
}

model ProviderDetails {
  id             String    @id @default(uuid())
  userId         String    @unique
  businessName   String?
  licenseNo      String?
  operatingHours Json?
  specialization Json?
  capacity       Int?
  locationId     String?
  location       Location? @relation(fields: [locationId], references: [id])
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("provider_details")
}

model Campus {
  id           String        @id @default(uuid())
  name         String
  address      Json
  coordinates  Json?
  timezone     String        @default("UTC")
  settings     Json?
  events       Event[]
  locations    Location[]
  userProfiles UserProfile[]

  @@map("campuses")
}

model Location {
  id              String            @id @default(uuid())
  campusId        String
  name            String
  type            LocationType
  coordinates     Json?
  contactInfo     Json?
  operatingHours  Json?
  events          Event[]
  listings        Listing[]
  campus          Campus            @relation(fields: [campusId], references: [id])
  providerDetails ProviderDetails[]

  @@map("locations")
}

model Listing {
  id                 String            @id @default(uuid())
  title              String
  description        String?
  foodItems          Json
  totalQuantity      Float
  unit               String
  freshness          FreshnessLevel
  allergens          Json?
  dietaryInfo        Json?
  safeUntil          DateTime
  availableFrom      DateTime
  availableUntil     DateTime
  pickupInstructions String?
  photos             Json?
  claimedQuantity    Float             @default(0)
  wastedQuantity     Float?
  isExpired          Boolean           @default(false)
  expiredAt          DateTime?
  providerId         String
  locationId         String
  status             ListingStatus     @default(AVAILABLE)
  priority           Priority          @default(MEDIUM)
  isRecurring        Boolean           @default(false)
  recurringPattern   Json?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  eventId            String?
  claims             Claim[]
  analytics          ListingAnalytics?
  event              Event?            @relation(fields: [eventId], references: [id])
  location           Location          @relation(fields: [locationId], references: [id])
  provider           User              @relation(fields: [providerId], references: [id])

  @@map("listings")
}

model Claim {
  id                String         @id @default(uuid())
  listingId         String
  receiverId        String
  requestedQuantity Float
  approvedQuantity  Float?
  pickupCode        String?
  pickupTime        DateTime?
  actualPickupTime  DateTime?
  notes             String?
  status            ClaimStatus    @default(PENDING)
  cancelReason      String?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  feedback          ClaimFeedback?
  listing           Listing        @relation(fields: [listingId], references: [id])
  receiver          User           @relation(fields: [receiverId], references: [id])

  @@map("claims")
}

model ClaimFeedback {
  id          String  @id @default(uuid())
  claimId     String  @unique
  rating      Int
  comment     String?
  foodQuality Int?
  experience  Int?
  claim       Claim   @relation(fields: [claimId], references: [id], onDelete: Cascade)

  @@map("claim_feedback")
}

model Event {
  id                String    @id @default(uuid())
  title             String
  description       String?
  startTime         DateTime
  endTime           DateTime
  campusId          String
  locationId        String?
  organizerEmail    String
  expectedAttendees Int?
  foodOrdered       Json?
  autoPromptEnabled Boolean   @default(true)
  promptSentAt      DateTime?
  campus            Campus    @relation(fields: [campusId], references: [id])
  location          Location? @relation(fields: [locationId], references: [id])
  listings          Listing[]

  @@map("events")
}

model NotificationLog {
  id          String              @id @default(uuid())
  userId      String
  type        NotificationType
  title       String
  message     String
  data        Json?
  channel     NotificationChannel
  sentAt      DateTime            @default(now())
  readAt      DateTime?
  actionTaken String?
  user        User                @relation(fields: [userId], references: [id])

  @@map("notification_logs")
}

model NotificationPreference {
  id              String  @id @default(uuid())
  userId          String  @unique
  enableEmail     Boolean @default(true)
  enablePush      Boolean @default(true)
  enableSMS       Boolean @default(false)
  newListings     Boolean @default(true)
  claimUpdates    Boolean @default(true)
  pickupReminders Boolean @default(true)
  weeklyDigest    Boolean @default(true)
  achievements    Boolean @default(true)
  quietHoursStart String?
  quietHoursEnd   String?
  timezone        String  @default("UTC")

  @@map("notification_preferences")
}

model ListingAnalytics {
  id               String  @id @default(uuid())
  listingId        String  @unique
  viewCount        Int     @default(0)
  claimCount       Int     @default(0)
  shareCount       Int     @default(0)
  carbonSaved      Float   @default(0)
  waterSaved       Float   @default(0)
  peopleServed     Int     @default(0)
  timeToFirstClaim Int?
  timeToFullClaim  Int?
  listing          Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@map("listing_analytics")
}

model UserAnalytics {
  id                   String   @id @default(uuid())
  userId               String   @unique
  listingsCreated      Int      @default(0)
  foodShared           Float    @default(0)
  carbonFootprintSaved Float    @default(0)
  waterFootprintSaved  Float    @default(0)
  claimsMade           Int      @default(0)
  foodReceived         Float    @default(0)
  moneySaved           Float    @default(0)
  streak               Int      @default(0)
  longestStreak        Int      @default(0)
  badges               Json?
  level                Int      @default(1)
  points               Int      @default(0)
  lastUpdated          DateTime @updatedAt
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_analytics")
}

model Subscription {
  id        String             @id @default(uuid())
  userId    String
  planId    String
  status    SubscriptionStatus
  startDate DateTime           @default(now())
  endDate   DateTime?
  autoRenew Boolean            @default(false)
  plan      SubscriptionPlan   @relation(fields: [planId], references: [id])
  user      User               @relation(fields: [userId], references: [id])

  @@map("subscriptions")
}

model SubscriptionPlan {
  id            String         @id @default(uuid())
  name          String         @unique
  price         Float
  currency      String         @default("USD")
  interval      String
  features      Json
  maxListings   Int?
  maxClaims     Int?
  priority      Boolean        @default(false)
  analytics     Boolean        @default(false)
  customization Boolean        @default(false)
  subscriptions Subscription[]

  @@map("subscription_plans")
}

model SystemConfig {
  id    String @id @default(uuid())
  key   String @unique
  value Json

  @@map("system_config")
}

enum UserRole {
  PROVIDER
  RECEIVER
  NGO
  ADMIN
  CANTEEN_MANAGER
}

enum NGOVerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum LocationType {
  CANTEEN
  HOSTEL
  EVENT_VENUE
  OFFICE
  OTHER
}

enum FreshnessLevel {
  FRESHLY_COOKED
  FRESH
  GOOD
  NEAR_EXPIRY
  USE_IMMEDIATELY
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum ListingStatus {
  DRAFT
  AVAILABLE
  PARTIALLY_CLAIMED
  FULLY_CLAIMED
  EXPIRED
  COMPLETED
  CANCELLED
}

enum ClaimStatus {
  PENDING
  APPROVED
  REJECTED
  CONFIRMED
  COMPLETED
  NO_SHOW
  CANCELLED
}

enum NotificationType {
  NEW_LISTING
  CLAIM_UPDATE
  PICKUP_REMINDER
  EXPIRY_WARNING
  SYSTEM_ANNOUNCEMENT
  ACHIEVEMENT
  WEEKLY_SUMMARY
}

enum NotificationChannel {
  IN_APP
  EMAIL
  SMS
  PUSH
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PAST_DUE
}
